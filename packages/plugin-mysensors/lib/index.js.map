{"version":3,"sources":["../../src/index.ts","index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","gwBaud","interfaces","Light","id","Dimmer","RGB","Temperature","statuses","status","on","level","color","temp","names","serialPorts","isGateway","device","deviceClassId","hex","string","toString","encode","destination","sensor","command","acknowledge","type","payload","message","i","length","MySensorsPlugin","openGateway","modification","send","bind","config","gateway","node","slice","red","green","blue","Error","interfaceId","call","arguments","subType","log","debug","write","state","list","where","pluginId","forEach","all","Object","values","map","port","close","console","JSON","stringify","serialPort","baudrate","parser","parsers","readline","errors","info","receivedMessage","rd","error","setTimeout","open","Math","pow","deviceId","callDevice","method","split","p","sender","ack","sensorPresented","statusUpdate","statusRequest","round","Date","now","nameReceived","trim","scalar","gatewayId","nodeId","getSensor","createDevice","name","upsertDevice","statusId","parseInt","substring","dispatch","statusUpdated","onDeviceStatusModified"],"mappings":"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","file":"index.js","sourcesContent":["import SerialPort from 'serialport'\nimport {\n  actions,\n  defaultInterfaces as raxaInterfaces,\n  isStatus,\n  Call,\n  Device,\n  Modification,\n  Plugin,\n} from 'raxa-common'\nimport {\n  C_INTERNAL,\n  C_PRESENTATION,\n  C_REQ,\n  C_SET,\n\n  I_CONFIG,\n  I_SKETCH_NAME,\n  I_TIME,\n\n  S_DIMMER,\n  S_BINARY,\n  S_RGB_LIGHT,\n  S_TEMP,\n\n  V_PERCENTAGE,\n  V_RGB,\n  V_STATUS,\n  V_TEMP,\n} from './definitions'\n\nconst gwBaud = 115200\n\nconst interfaces = {\n  [S_BINARY]: raxaInterfaces.Light.id,\n  [S_DIMMER]: raxaInterfaces.Dimmer.id,\n  [S_RGB_LIGHT]: raxaInterfaces.RGB.id,\n  [S_TEMP]: raxaInterfaces.Temperature.id,\n}\n\nconst statuses = {\n  [V_STATUS]: raxaInterfaces.Light.status.on,\n  [V_PERCENTAGE]: raxaInterfaces.Dimmer.status.level,\n  [V_RGB]: raxaInterfaces.RGB.status.color,\n  [V_TEMP]: raxaInterfaces.Temperature.status.temp,\n}\n\nconst names = {}\n\nconst serialPorts = {} as {[id: number]: SerialPort}\n\nexport interface SerialGateway extends Device {\n  config: {\n    serialPort: string,\n    [field: string]: any,\n  }\n}\n\nexport interface Sensor extends Device {\n  config: {\n    gateway: number,\n    node: number,\n    sensor: number,\n    [field: string]: any,\n  }\n}\n\nfunction isGateway(device: Device): device is SerialGateway {\n  return device.deviceClassId === 'Serial MySensors Gateway'\n}\n\nfunction hex(value: number) {\n  let string = ''\n  if (value < 16) {\n    string += '0'\n  }\n  string += value.toString(16)\n  return string\n}\n\nfunction encode(destination, sensor, command, acknowledge, type, payload) {\n  let message = destination.toString(10) + ';' +\n                sensor.toString(10) + ';' +\n                command.toString(10) + ';' +\n                acknowledge.toString(10) + ';' +\n                type.toString(10) + ';'\n\n  if (command === 4) {\n    for (let i = 0; i < payload.length; i++) {\n      message += hex(payload[i])\n    }\n  } else {\n    message += payload\n  }\n  message += '\\n'\n  return message\n}\n\nexport default class MySensorsPlugin extends Plugin {\n  onDeviceCreated(device: Sensor|SerialGateway) {\n    if (isGateway(device)) {\n      this.openGateway(device)\n    }\n  }\n\n  onDeviceStatusModified(modification: Modification, device: Sensor) {\n    const send = this.send.bind(\n      this,\n      device.config.gateway,\n      device.config.node,\n      0,\n      C_SET\n    )\n\n    if (isStatus(modification, raxaInterfaces.Light.status.on)) {\n      return send(\n        V_STATUS,\n        modification.value ? 1 : 0\n      )\n    } else if (isStatus(modification, raxaInterfaces.Dimmer.status.level)) {\n      return send(\n        V_PERCENTAGE,\n        ('00' + modification.value).slice(-3)\n      )\n    } else if (isStatus(modification, raxaInterfaces.RGB.status.color)) {\n      return send(\n        V_RGB,\n        hex(modification.value.red) +\n        hex(modification.value.green) +\n        hex(modification.value.blue)\n      )\n    }\n\n    throw new Error(`Can't modify status of ${modification.interfaceId}`)\n  }\n\n  onDeviceCalled(call: Call, device: Sensor|SerialGateway) {\n    if (isGateway(device)) {\n      const {node, sensor, type, subType, payload} = call.arguments\n      const message = encode(node, sensor, type, 0, subType, payload)\n\n      this.log.debug('transmitted message', message)\n      serialPorts[device.id].write(message)\n    }\n  }\n\n  start() {\n    this.state.list('devices', {where: {\n      pluginId: 'mysensors',\n      deviceClassId: 'Serial MySensors Gateway',\n    }})\n      .forEach(this.openGateway.bind(this))\n  }\n\n  stop() {\n    return Promise.all(Object.values(serialPorts)\n      .map(port => new Promise(resolve => port.close(resolve)))\n    )\n  }\n\n  private openGateway({id, config}: SerialGateway) {\n    console.log('openGateway', JSON.stringify({id}))\n    const serialPort = config.serialPort\n    const port = new SerialPort(serialPort, {\n      baudrate: gwBaud,\n      parser: SerialPort.parsers.readline('\\n'),\n    })\n\n    let errors = 0\n\n    port.on('open', () => {\n      this.log.info(`connected to serial gateway at ${serialPort}`)\n      serialPorts[id] = port\n      errors = 0\n    })\n\n    port.on('end', () => {\n      this.log.info(`disconnected from gateway at ${serialPort}`)\n      serialPorts[id]\n    })\n\n    port.on('data', rd => {\n      this.receivedMessage(id, rd)\n    })\n\n    port.on('error', () => {\n      this.log.error(`connection error - trying to reconnect to ${serialPort}`)\n\n      setTimeout(() => {\n        port.open()\n      }, (errors ** 2) * 1000)\n      errors++\n    })\n  }\n\n  private send(deviceId, node, sensor, type, subType, payload) {\n    return this.callDevice({\n      deviceId,\n      interfaceId: 'MySensors Gateway',\n      method: 'send',\n      arguments: {node, sensor, type, subType, payload},\n    })\n  }\n\n  private receivedMessage(deviceId: string, message: string) {\n    if (message === '') return\n\n    this.log.debug('received message', message)\n\n    // Decoding message\n    const [sender, sensor, command, ack, type, payload]:\n          [number, number, number, boolean, number, string] =\n        message.split(';').map((p, i) => i === 5 ? p : +p) as any\n\n    switch (command) {\n      case C_PRESENTATION:\n        this.sensorPresented(deviceId, sender, sensor, type)\n        break\n\n      case C_SET:\n        this.statusUpdate(deviceId, sender, sensor, type, payload)\n        break\n\n      case C_REQ:\n        this.statusRequest(deviceId, sender, sensor, type)\n        break\n\n      case C_INTERNAL:\n        const send = this.send.bind(\n          this,\n          deviceId,\n          sender,\n          sensor,\n          C_INTERNAL\n        )\n\n        switch (type) {\n          case I_TIME:\n            send(I_TIME, Math.round(Date.now() / 1000))\n            break\n\n          case I_CONFIG:\n            send(I_CONFIG, 'M')\n            break\n\n          case I_SKETCH_NAME:\n            this.nameReceived(deviceId, sender, payload.trim())\n            break\n        }\n\n        break\n    }\n  }\n\n  private getSensor(gateway, node, sensor) {\n    return this.state.scalar('devices', {where: {\n      pluginId: 'mysensors',\n      deviceClassId: 'MySensors Sensor',\n      config: {\n        gateway,\n        node,\n        sensor,\n      }\n    }})\n  }\n\n  private sensorPresented(gatewayId, nodeId, sensor, type) {\n    if (!interfaces[type]) return\n\n    const device = this.getSensor(gatewayId, nodeId, sensor)\n\n    if (!device) {\n      const createDevice = () => {\n        const name = names[`${gatewayId}:${nodeId}`] ||\n            `MySensors ${interfaces[type]} ${nodeId}:${sensor}`\n        const device: Sensor = {\n          id: '',\n          name,\n          pluginId: 'mysensors',\n          deviceClassId: 'MySensors Sensor',\n          config: {\n            gateway: gatewayId,\n            node: nodeId,\n            sensor,\n          },\n          interfaces: [interfaces[type]],\n        }\n\n        this.upsertDevice(device)\n      }\n\n      if (!names[`${gatewayId}:${nodeId}`]) {\n        setTimeout(createDevice, 100)\n      } else {\n        createDevice()\n      }\n    }\n  }\n\n  private nameReceived(gatewayId, nodeId, name) {\n    names[`${gatewayId}:${nodeId}`] = name\n    setTimeout(() => {\n      delete names[`${gatewayId}:${nodeId}`]\n    }, 10000)\n  }\n\n  private statusUpdate(gatewayId, nodeId, sensor, type, value) {\n    const status = statuses[type]\n    if (!status) return\n    const {interfaceId, id: statusId} = status\n\n    switch (type) {\n\n      case V_STATUS:\n        value = +value === 1\n        break\n\n      case V_TEMP:\n      case V_PERCENTAGE:\n        value = +value\n        break\n\n      case V_RGB:\n        value = {\n          red: parseInt(value.substring(0, 2), 16),\n          green: parseInt(value.substring(2, 4), 16),\n          blue: parseInt(value.substring(4, 6), 16),\n        }\n        break\n\n      default:\n        return\n    }\n\n    const device = this.getSensor(gatewayId, nodeId, sensor)\n\n    if (device) {\n      this.dispatch(\n        actions.statusUpdated,\n        {deviceId: device.id, interfaceId, statusId, value}\n      )\n    } else {\n      if (type === V_TEMP) {\n        const name = names[`${gatewayId}:${nodeId}`] ||\n            `MySensors ${interfaces[S_TEMP]} ${nodeId}:${sensor}`\n        const device: Sensor = {\n          id: '',\n          name,\n          pluginId: 'mysensors',\n          deviceClassId: 'MySensors Sensor',\n          config: {\n            gateway: gatewayId,\n            node: nodeId,\n            sensor,\n          },\n          interfaces: [interfaces[S_TEMP]],\n        }\n\n        this.upsertDevice(device)\n          .then(device => {\n            this.dispatch(\n              actions.statusUpdated,\n              {deviceId: device.id, interfaceId, statusId, value}\n            )\n          })\n      }\n    }\n  }\n\n  private async statusRequest(gatewayId, nodeId, sensor, type) {\n    const status = statuses[type]\n    if (!status) return\n    const {interfaceId, id: statusId} = status\n    const device = this.getSensor(gatewayId, nodeId, sensor)\n\n    if (device) {\n      const value = await this.state.scalar({status: {[device.id]: {[interfaceId]: statusId}}})\n\n      this.onDeviceStatusModified({\n        deviceId: device.id,\n        interfaceId,\n        statusId,\n        value,\n      }, device as Sensor)\n    }\n  }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport SerialPort from 'serialport';\nimport { actions, defaultInterfaces as raxaInterfaces, isStatus, Plugin, } from 'raxa-common';\nimport { C_INTERNAL, C_PRESENTATION, C_REQ, C_SET, I_CONFIG, I_SKETCH_NAME, I_TIME, S_DIMMER, S_BINARY, S_RGB_LIGHT, S_TEMP, V_PERCENTAGE, V_RGB, V_STATUS, V_TEMP, } from './definitions';\nconst gwBaud = 115200;\nconst interfaces = {\n    [S_BINARY]: raxaInterfaces.Light.id,\n    [S_DIMMER]: raxaInterfaces.Dimmer.id,\n    [S_RGB_LIGHT]: raxaInterfaces.RGB.id,\n    [S_TEMP]: raxaInterfaces.Temperature.id,\n};\nconst statuses = {\n    [V_STATUS]: raxaInterfaces.Light.status.on,\n    [V_PERCENTAGE]: raxaInterfaces.Dimmer.status.level,\n    [V_RGB]: raxaInterfaces.RGB.status.color,\n    [V_TEMP]: raxaInterfaces.Temperature.status.temp,\n};\nconst names = {};\nconst serialPorts = {};\nfunction isGateway(device) {\n    return device.deviceClassId === 'Serial MySensors Gateway';\n}\nfunction hex(value) {\n    let string = '';\n    if (value < 16) {\n        string += '0';\n    }\n    string += value.toString(16);\n    return string;\n}\nfunction encode(destination, sensor, command, acknowledge, type, payload) {\n    let message = destination.toString(10) + ';' +\n        sensor.toString(10) + ';' +\n        command.toString(10) + ';' +\n        acknowledge.toString(10) + ';' +\n        type.toString(10) + ';';\n    if (command === 4) {\n        for (let i = 0; i < payload.length; i++) {\n            message += hex(payload[i]);\n        }\n    }\n    else {\n        message += payload;\n    }\n    message += '\\n';\n    return message;\n}\nexport default class MySensorsPlugin extends Plugin {\n    onDeviceCreated(device) {\n        if (isGateway(device)) {\n            this.openGateway(device);\n        }\n    }\n    onDeviceStatusModified(modification, device) {\n        const send = this.send.bind(this, device.config.gateway, device.config.node, 0, C_SET);\n        if (isStatus(modification, raxaInterfaces.Light.status.on)) {\n            return send(V_STATUS, modification.value ? 1 : 0);\n        }\n        else if (isStatus(modification, raxaInterfaces.Dimmer.status.level)) {\n            return send(V_PERCENTAGE, ('00' + modification.value).slice(-3));\n        }\n        else if (isStatus(modification, raxaInterfaces.RGB.status.color)) {\n            return send(V_RGB, hex(modification.value.red) +\n                hex(modification.value.green) +\n                hex(modification.value.blue));\n        }\n        throw new Error(`Can't modify status of ${modification.interfaceId}`);\n    }\n    onDeviceCalled(call, device) {\n        if (isGateway(device)) {\n            const { node, sensor, type, subType, payload } = call.arguments;\n            const message = encode(node, sensor, type, 0, subType, payload);\n            this.log.debug('transmitted message', message);\n            serialPorts[device.id].write(message);\n        }\n    }\n    start() {\n        this.state.list('devices', { where: {\n                pluginId: 'mysensors',\n                deviceClassId: 'Serial MySensors Gateway',\n            } })\n            .forEach(this.openGateway.bind(this));\n    }\n    stop() {\n        return Promise.all(Object.values(serialPorts)\n            .map(port => new Promise(resolve => port.close(resolve))));\n    }\n    openGateway({ id, config }) {\n        console.log('openGateway', JSON.stringify({ id }));\n        const serialPort = config.serialPort;\n        const port = new SerialPort(serialPort, {\n            baudrate: gwBaud,\n            parser: SerialPort.parsers.readline('\\n'),\n        });\n        let errors = 0;\n        port.on('open', () => {\n            this.log.info(`connected to serial gateway at ${serialPort}`);\n            serialPorts[id] = port;\n            errors = 0;\n        });\n        port.on('end', () => {\n            this.log.info(`disconnected from gateway at ${serialPort}`);\n            serialPorts[id];\n        });\n        port.on('data', rd => {\n            this.receivedMessage(id, rd);\n        });\n        port.on('error', () => {\n            this.log.error(`connection error - trying to reconnect to ${serialPort}`);\n            setTimeout(() => {\n                port.open();\n            }, (Math.pow(errors, 2)) * 1000);\n            errors++;\n        });\n    }\n    send(deviceId, node, sensor, type, subType, payload) {\n        return this.callDevice({\n            deviceId,\n            interfaceId: 'MySensors Gateway',\n            method: 'send',\n            arguments: { node, sensor, type, subType, payload },\n        });\n    }\n    receivedMessage(deviceId, message) {\n        if (message === '')\n            return;\n        this.log.debug('received message', message);\n        // Decoding message\n        const [sender, sensor, command, ack, type, payload] = message.split(';').map((p, i) => i === 5 ? p : +p);\n        switch (command) {\n            case C_PRESENTATION:\n                this.sensorPresented(deviceId, sender, sensor, type);\n                break;\n            case C_SET:\n                this.statusUpdate(deviceId, sender, sensor, type, payload);\n                break;\n            case C_REQ:\n                this.statusRequest(deviceId, sender, sensor, type);\n                break;\n            case C_INTERNAL:\n                const send = this.send.bind(this, deviceId, sender, sensor, C_INTERNAL);\n                switch (type) {\n                    case I_TIME:\n                        send(I_TIME, Math.round(Date.now() / 1000));\n                        break;\n                    case I_CONFIG:\n                        send(I_CONFIG, 'M');\n                        break;\n                    case I_SKETCH_NAME:\n                        this.nameReceived(deviceId, sender, payload.trim());\n                        break;\n                }\n                break;\n        }\n    }\n    getSensor(gateway, node, sensor) {\n        return this.state.scalar('devices', { where: {\n                pluginId: 'mysensors',\n                deviceClassId: 'MySensors Sensor',\n                config: {\n                    gateway,\n                    node,\n                    sensor,\n                }\n            } });\n    }\n    sensorPresented(gatewayId, nodeId, sensor, type) {\n        if (!interfaces[type])\n            return;\n        const device = this.getSensor(gatewayId, nodeId, sensor);\n        if (!device) {\n            const createDevice = () => {\n                const name = names[`${gatewayId}:${nodeId}`] ||\n                    `MySensors ${interfaces[type]} ${nodeId}:${sensor}`;\n                const device = {\n                    id: '',\n                    name,\n                    pluginId: 'mysensors',\n                    deviceClassId: 'MySensors Sensor',\n                    config: {\n                        gateway: gatewayId,\n                        node: nodeId,\n                        sensor,\n                    },\n                    interfaces: [interfaces[type]],\n                };\n                this.upsertDevice(device);\n            };\n            if (!names[`${gatewayId}:${nodeId}`]) {\n                setTimeout(createDevice, 100);\n            }\n            else {\n                createDevice();\n            }\n        }\n    }\n    nameReceived(gatewayId, nodeId, name) {\n        names[`${gatewayId}:${nodeId}`] = name;\n        setTimeout(() => {\n            delete names[`${gatewayId}:${nodeId}`];\n        }, 10000);\n    }\n    statusUpdate(gatewayId, nodeId, sensor, type, value) {\n        const status = statuses[type];\n        if (!status)\n            return;\n        const { interfaceId, id: statusId } = status;\n        switch (type) {\n            case V_STATUS:\n                value = +value === 1;\n                break;\n            case V_TEMP:\n            case V_PERCENTAGE:\n                value = +value;\n                break;\n            case V_RGB:\n                value = {\n                    red: parseInt(value.substring(0, 2), 16),\n                    green: parseInt(value.substring(2, 4), 16),\n                    blue: parseInt(value.substring(4, 6), 16),\n                };\n                break;\n            default:\n                return;\n        }\n        const device = this.getSensor(gatewayId, nodeId, sensor);\n        if (device) {\n            this.dispatch(actions.statusUpdated, { deviceId: device.id, interfaceId, statusId, value });\n        }\n        else {\n            if (type === V_TEMP) {\n                const name = names[`${gatewayId}:${nodeId}`] ||\n                    `MySensors ${interfaces[S_TEMP]} ${nodeId}:${sensor}`;\n                const device = {\n                    id: '',\n                    name,\n                    pluginId: 'mysensors',\n                    deviceClassId: 'MySensors Sensor',\n                    config: {\n                        gateway: gatewayId,\n                        node: nodeId,\n                        sensor,\n                    },\n                    interfaces: [interfaces[S_TEMP]],\n                };\n                this.upsertDevice(device)\n                    .then(device => {\n                    this.dispatch(actions.statusUpdated, { deviceId: device.id, interfaceId, statusId, value });\n                });\n            }\n        }\n    }\n    statusRequest(gatewayId, nodeId, sensor, type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const status = statuses[type];\n            if (!status)\n                return;\n            const { interfaceId, id: statusId } = status;\n            const device = this.getSensor(gatewayId, nodeId, sensor);\n            if (device) {\n                const value = yield this.state.scalar({ status: { [device.id]: { [interfaceId]: statusId } } });\n                this.onDeviceStatusModified({\n                    deviceId: device.id,\n                    interfaceId,\n                    statusId,\n                    value,\n                }, device);\n            }\n        });\n    }\n}\n"]}