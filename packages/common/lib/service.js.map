{"version":3,"sources":["../../src/service.ts","service.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","selectScope","scope","state","Array","isArray","Error","keys","Object","length","subState","compareProps","element","where","whereProps","every","prop","filterList","list","options","properties","filter","StateQuery","storage","selectedData","getState","values","Service","ServiceManager","rootLogger","runningServices","startOrder","log","services","service","startService","name","info","serviceInstance","configureService","start","push","serviceManager","StorageService","dispatch","reverse","stopService","warn","stop","n"],"mappings":";;;;;;;;;;;;;;;AAEA;;;;;;ACFA,IAAIA,YAAa,aAAQ,UAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,WAAO,KAAKD,MAAMA,IAAIE,OAAV,CAAL,EAAyB,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AACvD,iBAASC,SAAT,CAAmBC,KAAnB,EAA0B;AAAE,gBAAI;AAAEC,qBAAKN,UAAUO,IAAV,CAAeF,KAAf,CAAL;AAA8B,aAApC,CAAqC,OAAOG,CAAP,EAAU;AAAEL,uBAAOK,CAAP;AAAY;AAAE;AAC3F,iBAASC,QAAT,CAAkBJ,KAAlB,EAAyB;AAAE,gBAAI;AAAEC,qBAAKN,UAAU,OAAV,EAAmBK,KAAnB,CAAL;AAAkC,aAAxC,CAAyC,OAAOG,CAAP,EAAU;AAAEL,uBAAOK,CAAP;AAAY;AAAE;AAC9F,iBAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,mBAAOC,IAAP,GAAcT,QAAQQ,OAAOL,KAAf,CAAd,GAAsC,IAAIN,CAAJ,CAAM,UAAUG,OAAV,EAAmB;AAAEA,wBAAQQ,OAAOL,KAAf;AAAwB,aAAnD,EAAqDO,IAArD,CAA0DR,SAA1D,EAAqEK,QAArE,CAAtC;AAAuH;AAC/IH,aAAK,CAACN,YAAYA,UAAUa,KAAV,CAAgBhB,OAAhB,EAAyBC,cAAc,EAAvC,CAAb,EAAyDS,IAAzD,EAAL;AACH,KALM,CAAP;AAMH,CAPD;;ADiBA,SAAAO,WAAA,CAAqBC,KAArB,EAAmCC,KAAnC,EAA6C;AAC3C,QAAI,OAAOD,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,QAAlD,EAA4D;AAC1D,eAAOC,SAASA,MAAMD,KAAN,CAAhB;AACD,KAFD,MAGK,IAAIE,MAAMC,OAAN,CAAcH,KAAd,CAAJ,EAA0B;AAC7B,cAAMI,MAAM,8BAAN,CAAN;AACD,KAFI,MAGA;AACH,YAAMC,OAAOC,OAAOD,IAAP,CAAYL,KAAZ,CAAb;AACA,YAAIK,KAAKE,MAAL,KAAgB,CAApB,EAAuB;AACrB,gBAAMC,WAAWT,YAAYM,KAAK,CAAL,CAAZ,EAAqBJ,KAArB,CAAjB;AACA,mBAAOF,YAAYC,MAAMK,KAAK,CAAL,CAAN,CAAZ,EAA4BG,QAA5B,CAAP;AACD,SAHD,MAGO;AACL,kBAAMJ,MAAM,qCAAN,CAAN;AACD;AACF;AACF;AAED,SAAAK,YAAA,CAAsBC,OAAtB,EAA+BC,KAA/B,EAAsCC,UAAtC,EAAgD;AAC9C,QAAI,CAACF,OAAL,EAAc,OAAO,KAAP;AACd,WAAOE,WAAWC,KAAX,CAAiB,gBAAI;AAC1B,YAAIF,MAAMG,IAAN,KAAe,QAAOH,MAAMG,IAAN,CAAP,MAAuB,QAA1C,EAAoD;AAClD,mBAAOL,aACLC,QAAQI,IAAR,CADK,EAELH,MAAMG,IAAN,CAFK,EAGLR,OAAOD,IAAP,CAAYM,MAAMG,IAAN,CAAZ,CAHK,CAAP;AAKD;AACD,eAAOJ,QAAQI,IAAR,MAAkBH,MAAMG,IAAN,CAAzB;AACD,KATM,CAAP;AAUD;AAED,SAAAC,UAAA,CAAoBC,IAApB,EAAiCC,OAAjC,EAAkD;AAChD,QAAI,CAACA,OAAL,EAAc,OAAOD,IAAP;AACd,QAAIC,QAAQN,KAAZ,EAAmB;AACjB,YAAMO,aAAaZ,OAAOD,IAAP,CAAYY,QAAQN,KAApB,CAAnB;AACAK,eAAOA,KAAKG,MAAL,CAAY;AAAA,mBAAWV,aAAaC,OAAb,EAAsBO,QAAQN,KAA9B,EAAqCO,UAArC,CAAX;AAAA,SAAZ,CAAP;AACD;AACD,WAAOF,IAAP;AACD;;IAEKI,U,WAAAA,U;AACJ,wBAAoBC,OAApB,EAA2B;AAAA;;AAAP,aAAAA,OAAA,GAAAA,OAAA;AAAW;;;;+BAExBrB,K,EAAciB,O,EAAiB;AACpC,mBAAO,KAAKD,IAAL,CAAUhB,KAAV,EAAiBiB,OAAjB,EAA0B,CAA1B,CAAP;AACD;;;6BAEIjB,K,EAAciB,O,EAAiB;AAClC,gBAAMK,eAAevB,YAAYC,KAAZ,EAAmB,KAAKqB,OAAL,CAAaE,QAAb,EAAnB,CAArB;AACA,gBAAI,CAACD,YAAL,EAAmB,OAAO,EAAP;AACnB,gBAAIpB,MAAMC,OAAN,CAAcmB,YAAd,CAAJ,EAAiC,OAAOP,WAAWO,YAAX,EAAyBL,OAAzB,CAAP;AACjC,mBAAOF,WAAWT,OAAOkB,MAAP,CAAcF,YAAd,CAAX,EAAwCL,OAAxC,CAAP;AACD;;;;;;IAGGQ,O,WAAAA,O;;;;;;;;AAOJ;;;;gCAIK,CAAgC;AAErC;;;;;;;+BAII,CAAgC;;;;;;IAOhCC,c,WAAAA,c;AAKJ,4BAAoBC,UAApB,EAA+B;AAAA;;AAAX,aAAAA,UAAA,GAAAA,UAAA;AAHpB,aAAAC,eAAA,GAA6C,EAA7C;AACA,aAAAC,UAAA,GAA4B,EAA5B;AAGE,aAAKC,GAAL,GAAW,aAAQ,gBAAR,EAA0BH,UAA1B,CAAX;AACD;AAED;;;;;;;wCAG6D;AAAA,8CAAtCI,QAAsC;AAAtCA,wBAAsC;AAAA;;ACxBvD,mBAAOlD,UAAU,IAAV,EAAgB,KAAK,CAArB,EAAwB,KAAK,CAA7B,6BAAgC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4CDyBrBkD,QCzBqB;;AAAA;AAAA;AAAA;AAAA;AAAA;;ADyBhCC,uCCzBgC;AAAA;AAAA,uCD0BnC,KAAKC,YAAL,CAAkBD,OAAlB,CC1BmC;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAhC,EAAP;AD4BL;;;qCAEkBA,O,EAA8B;ACvB3C,mBAAOnD,UAAU,IAAV,EAAgB,KAAK,CAArB,EAAwB,KAAK,CAA7B,6BAAgC;AAAA;AAAA;AAAA;AAAA;AAAA;ADwBpCqD,oCCxBoC,GDwB5BF,OCxB4B,CDwBpCE,ICxBoC;;ADyB3C,qCAAKJ,GAAL,CAASK,IAAT,uBAAkCD,IAAlC;AACME,+CC1BqC,GD0BnB,IAAIJ,OAAJ,EC1BmB;;AD2B3C,qCAAKK,gBAAL,CAAsBL,OAAtB,EAA+BI,eAA/B;AC3B2C;AAAA,uCD4BrCA,gBAAgBE,KAAhB,EC5BqC;;AAAA;AD6B3C,qCAAKT,UAAL,CAAgBU,IAAhB,CAAqBL,IAArB;AACA,qCAAKN,eAAL,CAAqBI,QAAQE,IAA7B,IAAqCE,eAArC;AACA,qCAAKN,GAAL,CAASK,IAAT,sBAAiCD,IAAjC;AC/B2C,kEDgCpCE,eChCoC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAhC,EAAP;ADiCL;;;yCAE0BJ,O,EAAgCI,e,EAAwB;AACjFA,4BAAgBN,GAAhB,GAAsB,aAAQE,QAAQE,IAAhB,EAAsB,KAAKP,UAA3B,CAAtB;AACAS,4BAAgBI,cAAhB,GAAiC,IAAjC;AACA,gBAAMnB,UAAU,KAAKO,eAAL,CAAqBa,cAArC;AACA,gBAAIpB,OAAJ,EAAa;AACXe,gCAAgBnC,KAAhB,GAAwB,IAAImB,UAAJ,CAAeC,OAAf,CAAxB;AACAe,gCAAgBM,QAAhB,GAA2BrB,QAAQqB,QAAnC;AACD;AACF;AAED;;;;;;uCAGkB;ACvBZ,mBAAO7D,UAAU,IAAV,EAAgB,KAAK,CAArB,EAAwB,KAAK,CAA7B,6BAAgC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CDwBxB,KAAKgD,UAAL,CAAgBc,OAAhB,ECxBwB;;AAAA;AAAA;AAAA;AAAA;AAAA;;ADwBhCT,oCCxBgC;AAAA;AAAA,uCDyBnC,KAAKU,WAAL,CAAiBV,IAAjB,CCzBmC;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAhC,EAAP;AD2BL;;;oCAEiBA,I,EAAY;ACtBxB,mBAAOrD,UAAU,IAAV,EAAgB,KAAK,CAArB,EAAwB,KAAK,CAA7B,6BAAgC;AAAA;AAAA;AAAA;AAAA;AAAA;ADuB3C,qCAAKiD,GAAL,CAASK,IAAT,uBAAkCD,IAAlC;AACMF,uCCxBqC,GDwB3B,KAAKJ,eAAL,CAAqBM,IAArB,CCxB2B;;AAAA,oCDyBtCF,OCzBsC;AAAA;AAAA;AAAA;;AAAA,kED0BlC,KAAKF,GAAL,CAASe,IAAT,cAAyBX,IAAzB,qBC1BkC;;AAAA;AAAA,qCD4BvCF,QAAQc,IC5B+B;AAAA;AAAA;AAAA;;AAAA;AAAA,uCD6BnCd,QAAQc,IAAR,EC7BmC;;AAAA;AD+B3C,qCAAKjB,UAAL,GAAkB,KAAKA,UAAL,CAAgBV,MAAhB,CAAuB;AAAA,2CAAK4B,MAAMb,IAAX;AAAA,iCAAvB,CAAlB;AACA,uCAAO,KAAKN,eAAL,CAAqBM,IAArB,CAAP;AACA,qCAAKJ,GAAL,CAASK,IAAT,sBAAiCD,IAAjC;;ACjC2C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAhC,EAAP;ADkCL","file":"service.js","sourcesContent":["import {Action} from 'redux-decorated'\nimport {Awaitable} from './entities'\nimport {Log} from './log'\n\nexport type Scope = string | number | ScopeObject | ScopeArray\nexport type ScopeObject = {[x: string]: Scope}\nexport interface ScopeArray extends Array<Scope> { }\n\nexport interface Options {\n  where: any\n}\n\nexport interface S {\n  scalar(scope: Scope, options?: Options): any\n  list(scope: Scope, options?: Options): any[]\n}\n\nfunction selectScope(scope: Scope, state: any) {\n  if (typeof scope === 'string' || typeof scope === 'number') {\n    return state && state[scope]\n  }\n  else if (Array.isArray(scope)) {\n    throw Error('array scope not impelemented')\n  }\n  else {\n    const keys = Object.keys(scope)\n    if (keys.length === 1) {\n      const subState = selectScope(keys[0], state)\n      return selectScope(scope[keys[0]], subState)\n    } else {\n      throw Error('object array scope not impelemented')\n    }\n  }\n}\n\nfunction compareProps(element, where, whereProps) {\n  if (!element) return false\n  return whereProps.every(prop => {\n    if (where[prop] && typeof where[prop] === 'object') {\n      return compareProps(\n        element[prop],\n        where[prop],\n        Object.keys(where[prop]),\n      )\n    }\n    return element[prop] === where[prop]\n  })\n}\n\nfunction filterList(list: any[], options?: Options) {\n  if (!options) return list\n  if (options.where) {\n    const properties = Object.keys(options.where)\n    list = list.filter(element => compareProps(element, options.where, properties))\n  }\n  return list\n}\n\nexport class StateQuery implements S {\n  constructor(private storage) {}\n\n  scalar(scope: Scope, options?: Options): any {\n    return this.list(scope, options)[0]\n  }\n\n  list(scope: Scope, options?: Options): any[] {\n    const selectedData = selectScope(scope, this.storage.getState())\n    if (!selectedData) return []\n    if (Array.isArray(selectedData)) return filterList(selectedData, options)\n    return filterList(Object.values(selectedData), options)\n  }\n}\n\nexport abstract class Service {\n  log: Log\n  serviceManager: ServiceManager\n\n  dispatch: <P>(action: Action<P>, payload: P) => void\n  state: S\n\n  /**\n   * Called when the service is stared, either becuse of beeing activated or when RAXA\n   * is starting. If a Promise is returned then RAXA will wait for it to be resolved.\n   */\n  start(): Awaitable<any> {/* empty */}\n\n  /**\n   * Called when the service is stopped, either becuse of beeing deactivated or when RAXA\n   * is stopping. If a Promise is returned then RAXA will wait for it to be resolved.\n   */\n  stop(): Awaitable<any> {/* empty */}\n}\n\nexport interface ServiceImplementation {\n  new(): Service\n}\n\nexport class ServiceManager {\n  log: Log\n  runningServices: {[name: string]: Service} = {}\n  startOrder: Array<string> = []\n\n  constructor(private rootLogger?) {\n    this.log = new Log('ServiceManager', rootLogger)\n  }\n\n  /**\n   * Starts all passed services\n   */\n  async startServices(...services: Array<ServiceImplementation>) {\n    for (const service of services) {\n      await this.startService(service)\n    }\n  }\n\n  async startService(service: ServiceImplementation) {\n    const {name} = service\n    this.log.info(`Starting service ${name}`)\n    const serviceInstance = new service()\n    this.configureService(service, serviceInstance)\n    await serviceInstance.start()\n    this.startOrder.push(name)\n    this.runningServices[service.name] = serviceInstance\n    this.log.info(`Started service ${name}`)\n    return serviceInstance\n  }\n\n  protected configureService(service: ServiceImplementation, serviceInstance: Service) {\n    serviceInstance.log = new Log(service.name, this.rootLogger)\n    serviceInstance.serviceManager = this\n    const storage = this.runningServices.StorageService\n    if (storage) {\n      serviceInstance.state = new StateQuery(storage)\n      serviceInstance.dispatch = storage.dispatch\n    }\n  }\n\n  /**\n   * Stops all services in the reverse order of how they started\n   */\n  async stopServices() {\n    for (const name of this.startOrder.reverse()) {\n      await this.stopService(name)\n    }\n  }\n\n  async stopService(name: string) {\n    this.log.info(`Stopping service ${name}`)\n    const service = this.runningServices[name]\n    if (!service) {\n      return this.log.warn(`Service ${name} is not running`)\n    }\n    if (service.stop) {\n      await service.stop()\n    }\n    this.startOrder = this.startOrder.filter(n => n !== name)\n    delete this.runningServices[name]\n    this.log.info(`Stopped service ${name}`)\n  }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Log } from './log';\nfunction selectScope(scope, state) {\n    if (typeof scope === 'string' || typeof scope === 'number') {\n        return state && state[scope];\n    }\n    else if (Array.isArray(scope)) {\n        throw Error('array scope not impelemented');\n    }\n    else {\n        const keys = Object.keys(scope);\n        if (keys.length === 1) {\n            const subState = selectScope(keys[0], state);\n            return selectScope(scope[keys[0]], subState);\n        }\n        else {\n            throw Error('object array scope not impelemented');\n        }\n    }\n}\nfunction compareProps(element, where, whereProps) {\n    if (!element)\n        return false;\n    return whereProps.every(prop => {\n        if (where[prop] && typeof where[prop] === 'object') {\n            return compareProps(element[prop], where[prop], Object.keys(where[prop]));\n        }\n        return element[prop] === where[prop];\n    });\n}\nfunction filterList(list, options) {\n    if (!options)\n        return list;\n    if (options.where) {\n        const properties = Object.keys(options.where);\n        list = list.filter(element => compareProps(element, options.where, properties));\n    }\n    return list;\n}\nexport class StateQuery {\n    constructor(storage) {\n        this.storage = storage;\n    }\n    scalar(scope, options) {\n        return this.list(scope, options)[0];\n    }\n    list(scope, options) {\n        const selectedData = selectScope(scope, this.storage.getState());\n        if (!selectedData)\n            return [];\n        if (Array.isArray(selectedData))\n            return filterList(selectedData, options);\n        return filterList(Object.values(selectedData), options);\n    }\n}\nexport class Service {\n    /**\n     * Called when the service is stared, either becuse of beeing activated or when RAXA\n     * is starting. If a Promise is returned then RAXA will wait for it to be resolved.\n     */\n    start() { }\n    /**\n     * Called when the service is stopped, either becuse of beeing deactivated or when RAXA\n     * is stopping. If a Promise is returned then RAXA will wait for it to be resolved.\n     */\n    stop() { }\n}\nexport class ServiceManager {\n    constructor(rootLogger) {\n        this.rootLogger = rootLogger;\n        this.runningServices = {};\n        this.startOrder = [];\n        this.log = new Log('ServiceManager', rootLogger);\n    }\n    /**\n     * Starts all passed services\n     */\n    startServices(...services) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const service of services) {\n                yield this.startService(service);\n            }\n        });\n    }\n    startService(service) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { name } = service;\n            this.log.info(`Starting service ${name}`);\n            const serviceInstance = new service();\n            this.configureService(service, serviceInstance);\n            yield serviceInstance.start();\n            this.startOrder.push(name);\n            this.runningServices[service.name] = serviceInstance;\n            this.log.info(`Started service ${name}`);\n            return serviceInstance;\n        });\n    }\n    configureService(service, serviceInstance) {\n        serviceInstance.log = new Log(service.name, this.rootLogger);\n        serviceInstance.serviceManager = this;\n        const storage = this.runningServices.StorageService;\n        if (storage) {\n            serviceInstance.state = new StateQuery(storage);\n            serviceInstance.dispatch = storage.dispatch;\n        }\n    }\n    /**\n     * Stops all services in the reverse order of how they started\n     */\n    stopServices() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const name of this.startOrder.reverse()) {\n                yield this.stopService(name);\n            }\n        });\n    }\n    stopService(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.log.info(`Stopping service ${name}`);\n            const service = this.runningServices[name];\n            if (!service) {\n                return this.log.warn(`Service ${name} is not running`);\n            }\n            if (service.stop) {\n                yield service.stop();\n            }\n            this.startOrder = this.startOrder.filter(n => n !== name);\n            delete this.runningServices[name];\n            this.log.info(`Stopped service ${name}`);\n        });\n    }\n}\n"]}